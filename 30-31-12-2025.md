# Class Notes: React Authentication System

**Date:** December 31, 2025  
**Topic:** Authentication Flow in React Application

---

## Overview

This lesson covers three critical files that work together to implement authentication in a React application:
1. **api.js** - API service layer with Axios
2. **AuthContext.js** - React Context for authentication state management
3. **Login.js** - Login page component

---

## 1. API Service Layer (`api.js`)

### Purpose
Centralized service for making HTTP requests to the backend API, handling authentication tokens, and managing API responses.

### Key Concepts

#### 1.1 Axios Instance Creation
```javascript
const api = axios.create({
  baseURL: API_BASE_URL,
});
```
- Creates a reusable axios instance with a base URL
- All requests made through this instance will automatically prepend the base URL
- Allows consistent configuration across all API calls

#### 1.2 Request Interceptor
```javascript
api.interceptors.request.use((config) => {
  const token = localStorage.getItem('token');
  if (token) {
    config.headers.Authorization = `Bearer ${token}`;
  }
  return config;
});
```

**What it does:**
- Intercepts every outgoing request BEFORE it's sent
- Retrieves JWT token from localStorage
- Automatically adds `Authorization` header with Bearer token
- Ensures authenticated requests without manually adding token each time

**Benefits:**
- DRY principle - don't repeat token logic in every API call
- Centralized authentication logic
- Automatic token attachment

#### 1.3 Response Interceptor
```javascript
api.interceptors.response.use(
  (response) => response,
  (error) => {
    if (error.response?.status === 401) {
      localStorage.removeItem('token');
      window.location.href = '/login';
    }
    return Promise.reject(error);
  }
);
```

**What it does:**
- Intercepts responses AFTER they're received
- On success: passes response through unchanged
- On 401 error (Unauthorized):
  - Removes invalid/expired token from localStorage
  - Redirects user to login page
- Prevents users from staying logged in with invalid tokens

#### 1.4 API Modules

**Auth API:**
```javascript
export const authAPI = {
  login: (credentials) => api.post('/auth/login', credentials),
  register: (userData) => api.post('/auth/register', userData),
  getProfile: () => api.get('/auth/profile'),
};
```

**Mobile API:**
- CRUD operations for mobile products
- Uses standard REST conventions (GET, POST, PUT, DELETE)

**Cart API:**
- Shopping cart operations
- Manage items, quantities, and cart state

**Order API:**
- Create and manage orders
- Update order status

**Admin API:**
- Nested object structure for admin operations
- Separate endpoints for users, mobiles, and orders
- Note: Admin mobile endpoints use different paths (`/admin/mobiles/add` vs `/mobiles`)

### Key Patterns

1. **Organized by Feature:** APIs grouped by business domain (auth, mobile, cart, etc.)
2. **Consistent Interface:** All methods return promises from axios
3. **Centralized Configuration:** One place to manage base URL, interceptors
4. **Error Handling:** Global error handling in interceptors

---

## 2. Authentication Context (`AuthContext.js`)

### Purpose
Provides global authentication state management using React Context API, allowing any component to access user information and auth methods.

### Key Concepts

#### 2.1 Context Creation
```javascript
const AuthContext = createContext();
```
- Creates a context object
- Used to share authentication state across component tree
- Avoids prop drilling

#### 2.2 AuthProvider Component

**State Management:**
```javascript
const [user, setUser] = useState(null);
const [loading, setLoading] = useState(true);
```
- `user`: Stores decoded JWT token data (id, email, role, etc.)
- `loading`: Prevents rendering before auth check completes

#### 2.3 Token Validation on Mount
```javascript
useEffect(() => {
  const token = localStorage.getItem('token');
  if (token) {
    try {
      const decoded = jwtDecode(token);
      // Check if token is expired
      if (decoded.exp * 1000 < Date.now()) {
        localStorage.removeItem('token');
        setUser(null);
      } else {
        setUser(decoded);
      }
    } catch (error) {
      console.error('Invalid token:', error);
      localStorage.removeItem('token');
    }
  }
  setLoading(false);
}, []);
```

**Flow:**
1. Check localStorage for existing token
2. Decode JWT to extract payload
3. Validate expiration time (JWT exp is in seconds, Date.now() is in milliseconds)
4. If valid: set user state
5. If invalid/expired: clear token and user
6. Set loading to false to allow app to render

**Why `decoded.exp * 1000`?**
- JWT `exp` claim is Unix timestamp in **seconds**
- JavaScript `Date.now()` returns **milliseconds**
- Multiply by 1000 to compare apples to apples

#### 2.4 Authentication Methods

**Login:**
```javascript
const login = (token) => {
  localStorage.setItem('token', token);
  const decoded = jwtDecode(token);
  setUser(decoded);
};
```
- Stores token in localStorage for persistence
- Decodes token to get user data
- Updates user state to trigger re-render

**Logout:**
```javascript
const logout = () => {
  localStorage.removeItem('token');
  setUser(null);
};
```
- Removes token from storage
- Clears user state
- App will react to null user (redirect to login, hide protected routes)

**Role Checking:**
```javascript
const isAdmin = () => user && user.role === 'admin';
const isCustomer = () => user && user.role === 'customer';
```
- Utility functions for role-based access control
- Used in routing and conditional rendering

#### 2.5 Context Provider
```javascript
<AuthContext.Provider value={{ user, login, logout, loading, isAdmin, isCustomer }}>
  {children}
</AuthContext.Provider>
```
- Wraps entire app (usually in index.js or App.js)
- Provides auth state and methods to all descendants
- Any component can access via `useAuth()` hook

#### 2.6 Custom Hook
```javascript
export const useAuth = () => {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
};
```
- Cleaner API for consuming context
- Error checking prevents misuse outside provider
- Returns: `{ user, login, logout, loading, isAdmin, isCustomer }`

---

## 3. Login Component (`Login.js`)

### Purpose
User interface for authentication, handling form input, validation, and login flow.

### Key Concepts

#### 3.1 Component State
```javascript
const [formData, setFormData] = useState({
  email: '',
  password: ''
});
const [errors, setErrors] = useState({});
const [loading, setLoading] = useState(false);
```

**Three pieces of state:**
1. `formData`: Controlled form inputs
2. `errors`: Validation/server error messages
3. `loading`: Button disable state during submission

#### 3.2 Hooks Usage
```javascript
const navigate = useNavigate();
const { login } = useAuth();
```
- `useNavigate`: React Router hook for programmatic navigation
- `useAuth`: Custom hook to access login method from AuthContext

#### 3.3 Form Handling

**Input Change Handler:**
```javascript
const handleChange = (e) => {
  const { name, value } = e.target;
  setFormData({
    ...formData,
    [name]: value
  });
  // Clear error for this field when user starts typing
  if (errors[name]) {
    setErrors({
      ...errors,
      [name]: ''
    });
  }
};
```

**Pattern:**
- Uses computed property names `[name]: value`
- Single handler for all inputs (DRY)
- Clears field-specific errors on input (better UX)
- Spread operator preserves other form fields

#### 3.4 Form Submission

```javascript
const handleSubmit = async (e) => {
  e.preventDefault();
  setErrors({});
  setLoading(true);
  
  try {
    const response = await authAPI.login(formData);
    login(response.data.data.token);
    
    const { role } = response.data.data.user;
    
    if (role === 'admin') {
      navigate('/admin/dashboard');
    } else {
      navigate('/customer/dashboard');
    }
  } catch (err) {
    setErrors({
      general: err.response?.data?.message || 'Login failed. Please try again.'
    });
  } finally {
    setLoading(false);
  }
};
```

**Flow:**
1. **Prevent default:** Stop form from refreshing page
2. **Reset errors:** Clear previous error messages
3. **Set loading:** Disable submit button
4. **Try block:**
   - Call `authAPI.login()` with email and password
   - Extract token from response: `response.data.data.token`
   - Call context's `login()` method to save token and update state
   - Extract user role from response
   - Navigate based on role (admin vs customer dashboard)
5. **Catch block:**
   - Display error message from server
   - Optional chaining `?.` prevents crashes if response structure differs
   - Fallback message if no server message available
6. **Finally block:**
   - Always runs (success or error)
   - Re-enable submit button

#### 3.5 Response Structure Understanding
```javascript
// Expected API Response:
{
  data: {
    data: {
      token: "eyJhbGc...",
      user: {
        role: "admin",
        name: "John Doe",
        email: "john@example.com"
      }
    }
  }
}
```
- Double `data` nesting (axios response.data, then API's data)
- Token stored in localStorage via `login()` method
- User role determines navigation path

#### 3.6 JSX Structure

**Error Display:**
```javascript
{errors.general && <div className="error-message">{errors.general}</div>}
```
- Conditional rendering with `&&` operator
- Shows global errors above form

**Form Groups:**
```javascript
<div className="form-group">
  <label htmlFor="email">Email *</label>
  <input
    type="email"
    id="email"
    name="name"
    value={formData.email}
    onChange={handleChange}
    className={errors.email ? 'error' : ''}
    required
  />
  {errors.email && <span className="error-message">{errors.email}</span>}
</div>
```

**Key attributes:**
- `value={formData.email}`: Controlled component (React controls value)
- `onChange={handleChange}`: Updates state on every keystroke
- `name="email"`: Must match formData key for dynamic update
- `className={errors.email ? 'error' : ''}`: Conditional styling
- `required`: HTML5 validation
- Field-specific error display below input

**Submit Button:**
```javascript
<button type="submit" className="btn-submit" disabled={loading}>
  {loading ? 'Logging in...' : 'Login'}
</button>
```
- Disabled during API call (prevents double submission)
- Dynamic text shows loading state
- `type="submit"` triggers form onSubmit

---

## How They Work Together

### Authentication Flow Diagram

```
1. User enters credentials in Login.js
   ↓
2. handleSubmit calls authAPI.login(formData)
   ↓
3. api.js sends POST to /api/auth/login
   (Request interceptor adds token if exists - not needed for login)
   ↓
4. Backend validates credentials, returns JWT token
   ↓
5. Response interceptor checks for errors
   ↓
6. Login.js receives token in response.data.data.token
   ↓
7. Calls login(token) from AuthContext
   ↓
8. AuthContext.login():
   - Saves token to localStorage
   - Decodes token with jwtDecode
   - Updates user state
   ↓
9. Login.js navigates to dashboard based on role
   ↓
10. Subsequent API calls automatically include token
    (Request interceptor adds Authorization header)
```

### Data Flow Example

**When user logs in:**
```
Login Component → authAPI → Backend → AuthContext → App Re-renders
```

**When user refreshes page:**
```
App Loads → AuthContext useEffect → Check localStorage →
Validate Token → Set User State → Render App
```

**When user makes authenticated request:**
```
Component → API method → Request Interceptor (adds token) →
Backend → Response Interceptor (checks 401) → Component
```

---

## Important Patterns & Best Practices

### 1. Separation of Concerns
- **api.js**: HTTP communication
- **AuthContext.js**: State management
- **Login.js**: UI and user interaction

### 2. Token Storage
- **localStorage**: Persists across sessions (even after browser close)
- **Alternative**: sessionStorage (clears when tab closes)
- **Security Note**: XSS vulnerable, but acceptable for many apps

### 3. JWT Decoding
- **jwtDecode**: Client-side decoding for reading payload
- **Does NOT validate**: Server must validate token
- **Use case**: Extract user info (role, email, etc.) without API call

### 4. Error Handling Layers
- **Input validation**: HTML5 required attribute
- **API errors**: Catch block in handleSubmit
- **Global auth errors**: Response interceptor (401)
- **User feedback**: Error state displays messages

### 5. Loading States
- Prevents double submissions
- Provides user feedback
- Disables button during async operations

### 6. Controlled Components
- React state is source of truth
- Form inputs controlled via value and onChange
- Enables validation, formatting, dynamic updates

### 7. Role-Based Access Control (RBAC)
- Role stored in JWT payload
- AuthContext provides helper methods
- Routes protected based on role
- Different dashboards for different users

---

## Common Issues & Solutions

### Issue 1: Token Not Included in Requests
**Cause:** Axios instance not used, or interceptor not set up  
**Solution:** Always use exported `api` instance, not raw axios

### Issue 2: Infinite Redirect Loop
**Cause:** Response interceptor redirects on 401, but login page also makes request  
**Solution:** Exclude login/register from automatic redirect, or handle differently

### Issue 3: User State Not Persisting on Refresh
**Cause:** Not checking localStorage on mount  
**Solution:** useEffect in AuthContext validates token from localStorage

### Issue 4: Token Expired But User Still Logged In
**Cause:** Not checking expiration time  
**Solution:** Validate `exp` claim in AuthContext useEffect

### Issue 5: "Cannot read property 'data' of undefined"
**Cause:** Response structure different than expected  
**Solution:** Use optional chaining `response?.data?.data?.token`

---

## Key Takeaways

1. **Axios interceptors** automate token management and error handling
2. **React Context** provides global state without prop drilling
3. **localStorage** enables session persistence across page refreshes
4. **JWT tokens** contain user data (but must be validated server-side)
5. **Controlled components** give React full control over form state
6. **Loading states** improve UX and prevent errors
7. **Role-based navigation** personalizes user experience
8. **Separation of concerns** makes code maintainable and testable

---

## Further Learning

- **JWT Structure:** Learn about header, payload, signature
- **Token Refresh:** Implement refresh tokens for better security
- **Protected Routes:** Create ProtectedRoute component
- **Form Validation:** Add client-side validation before submission
- **Error Boundaries:** Catch and handle React errors gracefully
- **Security:** httpOnly cookies vs localStorage for tokens
- **Testing:** Unit tests for auth logic, integration tests for flow

---

## Questions for Review

1. What is the purpose of axios request interceptors?
2. Why do we multiply JWT exp by 1000?
3. What happens when a 401 error occurs?
4. How does the login method in AuthContext work?
5. Why use controlled components instead of uncontrolled?
6. What is the difference between localStorage and sessionStorage?
7. How does role-based routing work in this implementation?
8. Why is the loading state important in form submission?

---

**End of Class Notes**
