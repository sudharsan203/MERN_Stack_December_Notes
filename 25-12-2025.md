# Class Notes: Register & Login Components + JavaScript Objects/Arrays

**Date:** December 25, 2025

---

## Part 1: React Register & Login Components

### 1. Register Component Overview

The Register component is a React functional component that handles user registration with form validation and local storage.

#### Key Features:
- **Form State Management** using `useState` hook
- **Client-side Validation** for all form fields
- **Local Storage** for persisting user data
- **Navigation** after successful registration

#### Component Structure:

```javascript
import React, { useState } from 'react';
import { useNavigate } from 'react-router-dom';
import './Auth.css';

function Register() {
  const navigate = useNavigate();
  
  // State for form data
  const [formData, setFormData] = useState({
    firstname: '',
    lastname: '',
    dateofbirth: '',
    phonenumber: '',
    email: '',
    password: '',
    confirmPassword: '',
    address: ''
  });

  // State for validation errors
  const [errors, setErrors] = useState({});
  
  // ... other functions
}
```

#### Key Concepts Used:

**1. Object Destructuring:**
```javascript
const handleChange = (event) => {
  const { name, value } = event.target;  // Destructuring
  // Instead of: const name = event.target.name; const value = event.target.value;
}
```

**2. Spread Operator for State Updates:**
```javascript
setFormData({
  ...formData,      // Spread existing formData
  [name]: value     // Update specific field
});
```

**3. Dynamic Property Names:**
```javascript
[name]: value  // Computed property name
```

#### Form Validation Logic:

```javascript
const validateForm = () => {
  const newErrors = {};

  // Check required fields
  if (!formData.firstname.trim()) {
    newErrors.firstname = 'First name is required';
  }

  // Email validation using regex
  if (!/\S+@\S+\.\S+/.test(formData.email)) {
    newErrors.email = 'Please enter a valid email address';
  }

  // Phone number validation
  if (!/^\d{10}$/.test(formData.phonenumber.replace(/[-\s]/g, ''))) {
    newErrors.phonenumber = 'Please enter a valid 10-digit phone number';
  }

  // Password matching
  if (formData.password !== formData.confirmPassword) {
    newErrors.confirmPassword = 'Passwords do not match';
  }

  return newErrors;
};
```

#### Form Submission:

```javascript
const handleSubmit = (e) => {
  e.preventDefault();  // Prevent default form submission
  
  const newErrors = validateForm();
  
  // Check if there are any errors
  if (Object.keys(newErrors).length > 0) {
    setErrors(newErrors);
    return;
  }

  // Get existing users from localStorage
  const users = JSON.parse(localStorage.getItem('users') || '[]');
  
  // Check if user already exists
  const userExists = users.some(
    user => user.email === formData.email || user.phonenumber === formData.phonenumber
  );

  if (userExists) {
    setErrors({ email: 'User already exists' });
    return;
  }

  // Add new user
  users.push({
    firstname: formData.firstname,
    lastname: formData.lastname,
    dateofbirth: formData.dateofbirth,
    phonenumber: formData.phonenumber,
    email: formData.email,
    password: formData.password,
    address: formData.address
  });

  // Save to localStorage
  localStorage.setItem('users', JSON.stringify(users));

  alert('Registration successful!');
  navigate('/login');
};
```

---

### 2. Login Component Overview

The Login component authenticates users against data stored in localStorage.

#### Component Structure:

```javascript
function Login() {
  const navigate = useNavigate();
  
  const [formData, setFormData] = useState({
    identifier: '',  // Email or phone number
    password: ''
  });

  const [errors, setErrors] = useState({});
}
```

#### Login Authentication Logic:

```javascript
const handleSubmit = (e) => {
  e.preventDefault();
  
  const newErrors = validateForm();
  
  if (Object.keys(newErrors).length > 0) {
    setErrors(newErrors);
    return;
  }

  // Get users from localStorage
  const users = JSON.parse(localStorage.getItem('users') || '[]');
  
  // Find matching user
  const user = users.find(
    u => (u.email === formData.identifier || u.phonenumber === formData.identifier) 
         && u.password === formData.password
  );

  if (user) {
    // Store logged-in user info in sessionStorage
    sessionStorage.setItem('currentUser', JSON.stringify({
      firstname: user.firstname,
      lastname: user.lastname,
      email: user.email
    }));
    
    alert(`Welcome back, ${user.firstname}!`);
    navigate('/');
  } else {
    setErrors({
      identifier: 'Invalid credentials'
    });
  }
};
```

#### Key Differences: localStorage vs sessionStorage

| Feature | localStorage | sessionStorage |
|---------|--------------|----------------|
| **Lifetime** | Persists until explicitly cleared | Cleared when page session ends |
| **Scope** | Shared across all tabs/windows | Limited to single tab/window |
| **Use Case** | User data, preferences | Temporary session data |

---

## Part 2: JavaScript Objects & Arrays - Constructing & Destructuring

### 1. Creating (Constructing) Objects

#### Method 1: Object Literal (Most Common)
```javascript
const person = {
  firstname: 'John',
  lastname: 'Doe',
  age: 30,
  email: 'john@example.com'
};
```

#### Method 2: Using `new Object()`
```javascript
const person = new Object();
person.firstname = 'John';
person.lastname = 'Doe';
person.age = 30;
```

#### Method 3: Using Constructor Function
```javascript
function Person(firstname, lastname, age) {
  this.firstname = firstname;
  this.lastname = lastname;
  this.age = age;
}

const person1 = new Person('John', 'Doe', 30);
```

#### Method 4: Using Object.create()
```javascript
const personPrototype = {
  greet: function() {
    return `Hello, ${this.firstname}`;
  }
};

const person = Object.create(personPrototype);
person.firstname = 'John';
person.lastname = 'Doe';
```

#### Method 5: Using ES6 Class (Modern)
```javascript
class Person {
  constructor(firstname, lastname, age) {
    this.firstname = firstname;
    this.lastname = lastname;
    this.age = age;
  }
  
  greet() {
    return `Hello, ${this.firstname}`;
  }
}

const person1 = new Person('John', 'Doe', 30);
```

---

### 2. Object Destructuring

#### Basic Destructuring:
```javascript
const person = {
  firstname: 'John',
  lastname: 'Doe',
  age: 30,
  email: 'john@example.com'
};

// Extract properties into variables
const { firstname, lastname, age } = person;

console.log(firstname); // 'John'
console.log(lastname);  // 'Doe'
console.log(age);       // 30
```

#### Renaming Variables:
```javascript
const { firstname: first, lastname: last } = person;

console.log(first); // 'John'
console.log(last);  // 'Doe'
```

#### Default Values:
```javascript
const { firstname, country = 'USA' } = person;

console.log(country); // 'USA' (default, since not in object)
```

#### Nested Destructuring:
```javascript
const user = {
  name: 'John',
  address: {
    city: 'New York',
    country: 'USA',
    zipcode: '10001'
  }
};

const { address: { city, country } } = user;

console.log(city);    // 'New York'
console.log(country); // 'USA'
```

#### Function Parameter Destructuring:
```javascript
function displayUser({ firstname, lastname, age }) {
  console.log(`${firstname} ${lastname} is ${age} years old`);
}

displayUser(person); // 'John Doe is 30 years old'
```

#### Real Example from Register Component:
```javascript
const handleChange = (event) => {
  const { name, value } = event.target;
  // Instead of:
  // const name = event.target.name;
  // const value = event.target.value;
  
  setFormData({
    ...formData,
    [name]: value
  });
};
```

---

### 3. Creating (Constructing) Arrays

#### Method 1: Array Literal (Most Common)
```javascript
const fruits = ['apple', 'banana', 'orange'];
const numbers = [1, 2, 3, 4, 5];
const mixed = ['text', 42, true, { name: 'John' }];
```

#### Method 2: Using `new Array()`
```javascript
const arr1 = new Array();           // Empty array []
const arr2 = new Array(5);          // Array with 5 empty slots
const arr3 = new Array(1, 2, 3);    // [1, 2, 3]
```

#### Method 3: Array.from()
```javascript
// Create array from string
const chars = Array.from('hello'); // ['h', 'e', 'l', 'l', 'o']

// Create array with mapping
const numbers = Array.from({ length: 5 }, (_, i) => i + 1);
// [1, 2, 3, 4, 5]
```

#### Method 4: Array.of()
```javascript
const arr = Array.of(1, 2, 3, 4, 5); // [1, 2, 3, 4, 5]
```

#### Method 5: Spread Operator
```javascript
const arr1 = [1, 2, 3];
const arr2 = [4, 5, 6];
const combined = [...arr1, ...arr2]; // [1, 2, 3, 4, 5, 6]
```

---

### 4. Array Destructuring

#### Basic Destructuring:
```javascript
const colors = ['red', 'green', 'blue', 'yellow'];

const [first, second, third] = colors;

console.log(first);  // 'red'
console.log(second); // 'green'
console.log(third);  // 'blue'
```

#### Skipping Elements:
```javascript
const [first, , third] = colors; // Skip second element

console.log(first); // 'red'
console.log(third); // 'blue'
```

#### Rest Operator:
```javascript
const [first, second, ...rest] = colors;

console.log(first);  // 'red'
console.log(second); // 'green'
console.log(rest);   // ['blue', 'yellow']
```

#### Default Values:
```javascript
const [a, b, c, d, e = 'purple'] = colors;

console.log(e); // 'yellow' (exists in array)

const [x, y, z, w, v = 'default'] = ['a', 'b', 'c'];
console.log(v); // 'default' (not in array)
```

#### Swapping Variables:
```javascript
let a = 1;
let b = 2;

[a, b] = [b, a]; // Swap values

console.log(a); // 2
console.log(b); // 1
```

#### Nested Array Destructuring:
```javascript
const matrix = [[1, 2], [3, 4], [5, 6]];

const [[a, b], [c, d]] = matrix;

console.log(a); // 1
console.log(b); // 2
console.log(c); // 3
console.log(d); // 4
```

#### Function Return Destructuring:
```javascript
function getUserData() {
  return ['John', 'Doe', 30];
}

const [firstname, lastname, age] = getUserData();

console.log(firstname); // 'John'
console.log(lastname);  // 'Doe'
console.log(age);       // 30
```

---

### 5. Spread Operator (...) - Advanced Usage

#### Objects:

```javascript
// Copying objects
const original = { a: 1, b: 2 };
const copy = { ...original };

// Merging objects
const obj1 = { a: 1, b: 2 };
const obj2 = { c: 3, d: 4 };
const merged = { ...obj1, ...obj2 }; // { a: 1, b: 2, c: 3, d: 4 }

// Updating properties
const updated = { ...original, b: 10 }; // { a: 1, b: 10 }

// Adding new properties
const extended = { ...original, c: 3 }; // { a: 1, b: 2, c: 3 }
```

**Real Example from Register Component:**
```javascript
setFormData({
  ...formData,      // Copy all existing properties
  [name]: value     // Update specific property
});
```

#### Arrays:

```javascript
// Copying arrays
const original = [1, 2, 3];
const copy = [...original];

// Concatenating arrays
const arr1 = [1, 2, 3];
const arr2 = [4, 5, 6];
const combined = [...arr1, ...arr2]; // [1, 2, 3, 4, 5, 6]

// Adding elements
const withNew = [0, ...arr1, 4]; // [0, 1, 2, 3, 4]
```

---

### 6. Practical Examples

#### Example 1: Form Handling (React Pattern)
```javascript
// Initial state
const [formData, setFormData] = useState({
  email: '',
  password: '',
  rememberMe: false
});

// Handle input change
const handleChange = (e) => {
  const { name, value, type, checked } = e.target;
  
  setFormData(prevState => ({
    ...prevState,
    [name]: type === 'checkbox' ? checked : value
  }));
};
```

#### Example 2: API Response Handling
```javascript
// API response
const response = {
  status: 200,
  data: {
    user: {
      id: 1,
      firstname: 'John',
      lastname: 'Doe',
      email: 'john@example.com'
    },
    token: 'abc123'
  }
};

// Destructuring
const {
  data: {
    user: { firstname, lastname, email },
    token
  }
} = response;

console.log(firstname); // 'John'
console.log(token);     // 'abc123'
```

#### Example 3: Array Methods with Destructuring
```javascript
const users = [
  { id: 1, name: 'John', age: 30 },
  { id: 2, name: 'Jane', age: 25 },
  { id: 3, name: 'Bob', age: 35 }
];

// Map with destructuring
const names = users.map(({ name }) => name);
// ['John', 'Jane', 'Bob']

// Filter with destructuring
const adults = users.filter(({ age }) => age >= 30);
// [{ id: 1, name: 'John', age: 30 }, { id: 3, name: 'Bob', age: 35 }]

// Find with destructuring
const user = users.find(({ id }) => id === 2);
// { id: 2, name: 'Jane', age: 25 }
```

#### Example 4: Rest Parameters in Functions
```javascript
function sum(...numbers) {
  return numbers.reduce((total, num) => total + num, 0);
}

console.log(sum(1, 2, 3, 4, 5)); // 15

function createUser(firstname, lastname, ...otherInfo) {
  return {
    firstname,
    lastname,
    metadata: otherInfo
  };
}

const user = createUser('John', 'Doe', 30, 'USA', 'Developer');
// {
//   firstname: 'John',
//   lastname: 'Doe',
//   metadata: [30, 'USA', 'Developer']
// }
```

---

## Summary

### Register Component Key Points:
1. Uses controlled components with `useState`
2. Implements client-side validation
3. Uses localStorage for data persistence
4. Destructures event.target for cleaner code
5. Uses spread operator for immutable state updates

### Login Component Key Points:
1. Authenticates against localStorage data
2. Uses Array.find() to locate user
3. Stores session data in sessionStorage
4. Implements programmatic navigation with useNavigate

### Object/Array Concepts:
1. **Objects**: Can be created using literals, constructors, classes, or Object.create()
2. **Destructuring**: Extracts values from objects/arrays into variables
3. **Spread Operator**: Copies and merges objects/arrays immutably
4. **Rest Operator**: Collects remaining elements into an array
5. **Dynamic Property Names**: Uses computed property names [name]: value

---

## Interview Questions

1. **What's the difference between localStorage and sessionStorage?**
   - localStorage persists even after browser closes, sessionStorage clears when tab closes

2. **Why use the spread operator in React state updates?**
   - To maintain immutability and trigger re-renders properly

3. **What's the benefit of destructuring in function parameters?**
   - Cleaner code, explicit parameter names, can set defaults easily

4. **How do you prevent default form submission in React?**
   - Use `e.preventDefault()` in the submit handler

5. **What's the difference between `...rest` in objects vs arrays?**
   - Same concept: collects remaining elements, but objects collect key-value pairs, arrays collect indexed values

---

**End of Notes**
