# Class Notes - Asynchronous JavaScript
## Topic: Callbacks, Promises, Async/Await & Event Loop

---

## Table of Contents
1. [Synchronous vs Asynchronous Code](#synchronous-vs-asynchronous)
2. [Callbacks](#callbacks)
3. [Promises](#promises)
4. [Promise.all](#promiseall)
5. [Promise.allSettled](#promiseallsettled)
6. [Async/Await](#asyncawait)
7. [Event Loop](#event-loop)
8. [Comparison & Best Practices](#comparison)

---

## 1. Synchronous vs Asynchronous Code {#synchronous-vs-asynchronous}

### Synchronous Code
Code executes line by line, blocking the next operation until current one completes.

```javascript
console.log("First");
console.log("Second");
console.log("Third");

// Output:
// First
// Second
// Third
```

### Asynchronous Code
Code doesn't wait for an operation to complete before moving to the next line.

```javascript
console.log("First");
setTimeout(() => console.log("Second"), 1000);
console.log("Third");

// Output:
// First
// Third
// Second (after 1 second)
```

**Why Asynchronous?**
- Prevents blocking (UI remains responsive)
- Handles I/O operations (file reading, API calls, database queries)
- Better performance and user experience

---

## 2. Callbacks {#callbacks}

### Definition
A **callback** is a function passed as an argument to another function, which is then executed after some operation completes.

### Basic Example
```javascript
function greet(name, callback) {
  console.log("Hello, " + name);
  callback();
}

function sayGoodbye() {
  console.log("Goodbye!");
}

greet("Alice", sayGoodbye);

// Output:
// Hello, Alice
// Goodbye!
```

### Real-World Example: File Reading
```javascript
const fs = require('fs');

// Asynchronous file reading with callback
fs.readFile('data.txt', 'utf8', (error, data) => {
  if (error) {
    console.error("Error reading file:", error);
    return;
  }
  console.log("File contents:", data);
});

console.log("Reading file...");

// Output:
// Reading file...
// File contents: [contents of data.txt]
```

### Callback Pattern
```javascript
function asyncOperation(parameter, callback) {
  // Perform async operation
  setTimeout(() => {
    const error = null;  // or error object if something went wrong
    const result = "Operation complete";
    
    // Convention: callback(error, result)
    callback(error, result);
  }, 1000);
}

// Usage
asyncOperation("test", (err, result) => {
  if (err) {
    console.error("Error:", err);
    return;
  }
  console.log("Success:", result);
});
```

### The Problem: Callback Hell (Pyramid of Doom)
```javascript
// Example: Multiple nested async operations
getUserData(userId, (err, user) => {
  if (err) {
    console.error(err);
  } else {
    getOrders(user.id, (err, orders) => {
      if (err) {
        console.error(err);
      } else {
        getOrderDetails(orders[0].id, (err, details) => {
          if (err) {
            console.error(err);
          } else {
            processPayment(details, (err, payment) => {
              if (err) {
                console.error(err);
              } else {
                console.log("Payment processed:", payment);
              }
            });
          }
        });
      }
    });
  }
});
```

**Problems:**
- Hard to read and maintain
- Error handling repeated at each level
- Difficult to debug
- Leads to "callback hell"

---

## 3. Promises {#promises}

### Definition
A **Promise** is an object representing the eventual completion (or failure) of an asynchronous operation.

### Promise States
1. **Pending**: Initial state, neither fulfilled nor rejected
2. **Fulfilled**: Operation completed successfully
3. **Rejected**: Operation failed

```
Pending ‚Üí Fulfilled (resolved with a value)
       ‚Üí Rejected (rejected with an error)
```

### Creating a Promise
```javascript
const myPromise = new Promise((resolve, reject) => {
  // Async operation
  const success = true;
  
  setTimeout(() => {
    if (success) {
      resolve("Operation successful!");  // Fulfill the promise
    } else {
      reject("Operation failed!");       // Reject the promise
    }
  }, 1000);
});
```

### Consuming a Promise
```javascript
myPromise
  .then((result) => {
    console.log("Success:", result);
  })
  .catch((error) => {
    console.error("Error:", error);
  })
  .finally(() => {
    console.log("Promise settled (completed)");
  });
```

**Methods:**
- `.then(callback)`: Called when promise is fulfilled
- `.catch(callback)`: Called when promise is rejected
- `.finally(callback)`: Called regardless of outcome

### Chaining Promises
```javascript
function getUserData(userId) {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      resolve({ id: userId, name: "John Doe" });
    }, 1000);
  });
}

function getOrders(userId) {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      resolve([{ id: 1, item: "Laptop" }, { id: 2, item: "Mouse" }]);
    }, 1000);
  });
}

function getOrderDetails(orderId) {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      resolve({ id: orderId, price: 999, status: "shipped" });
    }, 1000);
  });
}

// Promise Chaining - Much cleaner than callbacks!
getUserData(123)
  .then((user) => {
    console.log("User:", user.name);
    return getOrders(user.id);
  })
  .then((orders) => {
    console.log("Orders:", orders.length);
    return getOrderDetails(orders[0].id);
  })
  .then((details) => {
    console.log("Order details:", details);
  })
  .catch((error) => {
    console.error("Error occurred:", error);
  });
```

### Real-World Example: Fetch API
```javascript
fetch('https://api.example.com/users')
  .then(response => {
    if (!response.ok) {
      throw new Error('Network response was not ok');
    }
    return response.json();
  })
  .then(data => {
    console.log("Users:", data);
  })
  .catch(error => {
    console.error("Fetch error:", error);
  });
```

---

## 4. Promise.all {#promiseall}

### Definition
`Promise.all()` takes an array of promises and returns a single promise that:
- **Resolves** when ALL promises resolve (with array of all results)
- **Rejects** as soon as ANY promise rejects (with that error)

### Syntax
```javascript
Promise.all([promise1, promise2, promise3])
  .then((results) => {
    // results is an array: [result1, result2, result3]
  })
  .catch((error) => {
    // First rejection error
  });
```

### Example: Parallel API Calls
```javascript
function fetchUser(id) {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve({ id, name: `User ${id}` });
    }, 1000);
  });
}

function fetchPosts(userId) {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve([{ id: 1, title: "Post 1" }]);
    }, 1500);
  });
}

function fetchComments(postId) {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve([{ id: 1, text: "Nice post!" }]);
    }, 800);
  });
}

// Execute all promises in parallel
const startTime = Date.now();

Promise.all([
  fetchUser(1),
  fetchPosts(1),
  fetchComments(1)
])
  .then(([user, posts, comments]) => {
    console.log("User:", user);
    console.log("Posts:", posts);
    console.log("Comments:", comments);
    console.log("Time taken:", Date.now() - startTime, "ms");
    // Time: ~1500ms (longest promise), not 3300ms (sum)
  })
  .catch((error) => {
    console.error("Error:", error);
  });
```

### Use Cases
‚úÖ When you need ALL results before proceeding  
‚úÖ Independent operations that can run in parallel  
‚úÖ Loading multiple resources simultaneously  

### Important: Fail-Fast Behavior
```javascript
const promise1 = Promise.resolve(1);
const promise2 = Promise.reject("Error!");
const promise3 = Promise.resolve(3);

Promise.all([promise1, promise2, promise3])
  .then((results) => {
    console.log(results);  // This won't execute
  })
  .catch((error) => {
    console.error(error);  // "Error!" - fails immediately
  });
```

**Key Point:** If ANY promise rejects, `Promise.all()` immediately rejects, even if other promises are still pending.

---

## 5. Promise.allSettled {#promiseallsettled}

### Definition
`Promise.allSettled()` waits for ALL promises to settle (either fulfilled or rejected), then returns an array of objects describing the outcome of each promise.

### Difference from Promise.all
| Feature | Promise.all | Promise.allSettled |
|---------|-------------|-------------------|
| Waits for | All to resolve OR first rejection | All to settle (resolve or reject) |
| Returns | Array of results | Array of result objects |
| Rejects when | Any promise rejects | Never rejects |
| Use when | All must succeed | Want all results regardless |

### Syntax
```javascript
Promise.allSettled([promise1, promise2, promise3])
  .then((results) => {
    // results is always an array of objects
    results.forEach((result) => {
      if (result.status === 'fulfilled') {
        console.log("Success:", result.value);
      } else {
        console.error("Error:", result.reason);
      }
    });
  });
```

### Result Object Format
```javascript
// For fulfilled promise:
{ status: 'fulfilled', value: resultValue }

// For rejected promise:
{ status: 'rejected', reason: errorReason }
```

### Example: Multiple API Calls with Error Handling
```javascript
function fetchUserProfile(id) {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      if (id === 1) {
        resolve({ id: 1, name: "Alice" });
      } else {
        reject("User not found");
      }
    }, 1000);
  });
}

function fetchUserPosts(id) {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      reject("Posts API is down");
    }, 500);
  });
}

function fetchUserFollowers(id) {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve({ count: 150 });
    }, 800);
  });
}

Promise.allSettled([
  fetchUserProfile(1),
  fetchUserPosts(1),
  fetchUserFollowers(1)
])
  .then((results) => {
    console.log("All operations completed:");
    
    results.forEach((result, index) => {
      console.log(`\nOperation ${index + 1}:`);
      if (result.status === 'fulfilled') {
        console.log("  Status: Success");
        console.log("  Data:", result.value);
      } else {
        console.log("  Status: Failed");
        console.log("  Error:", result.reason);
      }
    });
  });

// Output:
// All operations completed:
//
// Operation 1:
//   Status: Success
//   Data: { id: 1, name: 'Alice' }
//
// Operation 2:
//   Status: Failed
//   Error: Posts API is down
//
// Operation 3:
//   Status: Success
//   Data: { count: 150 }
```

### Use Cases
‚úÖ When you want results from all operations, even if some fail  
‚úÖ Batch processing where partial success is acceptable  
‚úÖ Dashboard loading multiple widgets independently  
‚úÖ Error reporting for multiple operations  

### Practical Example: Loading Dashboard
```javascript
async function loadDashboard() {
  const results = await Promise.allSettled([
    fetchSalesData(),
    fetchInventory(),
    fetchCustomerStats(),
    fetchRecentOrders()
  ]);

  // Display successful widgets, show errors for failed ones
  results.forEach((result, index) => {
    const widgetName = ['Sales', 'Inventory', 'Customers', 'Orders'][index];
    
    if (result.status === 'fulfilled') {
      displayWidget(widgetName, result.value);
    } else {
      showErrorWidget(widgetName, result.reason);
    }
  });
}
```

---

## 6. Async/Await {#asyncawait}

### Definition
`async/await` is syntactic sugar over Promises, making asynchronous code look and behave more like synchronous code.

### async Function
- Declared with `async` keyword
- Always returns a Promise
- Allows use of `await` inside

```javascript
async function myFunction() {
  return "Hello";  // Automatically wrapped in Promise.resolve()
}

// Equivalent to:
function myFunction() {
  return Promise.resolve("Hello");
}

// Usage:
myFunction().then(result => console.log(result));  // "Hello"
```

### await Keyword
- Can only be used inside `async` functions
- Pauses execution until Promise settles
- Returns the fulfilled value
- Throws error if Promise rejects

```javascript
async function fetchData() {
  const result = await somePromise;  // Waits for promise
  console.log(result);               // Uses the result
}
```

### Example: Converting Promise Chain to Async/Await

**With Promises:**
```javascript
function getCompleteUserData(userId) {
  return getUserData(userId)
    .then((user) => {
      return getOrders(user.id);
    })
    .then((orders) => {
      return getOrderDetails(orders[0].id);
    })
    .then((details) => {
      return details;
    })
    .catch((error) => {
      console.error("Error:", error);
      throw error;
    });
}
```

**With Async/Await:**
```javascript
async function getCompleteUserData(userId) {
  try {
    const user = await getUserData(userId);
    const orders = await getOrders(user.id);
    const details = await getOrderDetails(orders[0].id);
    return details;
  } catch (error) {
    console.error("Error:", error);
    throw error;
  }
}
```

### Error Handling with try/catch
```javascript
async function fetchUserProfile(id) {
  try {
    const response = await fetch(`/api/users/${id}`);
    
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    
    const user = await response.json();
    console.log("User:", user);
    return user;
    
  } catch (error) {
    console.error("Failed to fetch user:", error.message);
    throw error;  // Re-throw if needed
  }
}
```

### Parallel Execution with Async/Await
```javascript
// ‚ùå WRONG: Sequential execution (slow)
async function loadDataSequential() {
  const user = await fetchUser();      // Wait 1s
  const posts = await fetchPosts();    // Wait another 1s
  const comments = await fetchComments(); // Wait another 1s
  // Total: 3 seconds
  return { user, posts, comments };
}

// ‚úÖ CORRECT: Parallel execution (fast)
async function loadDataParallel() {
  // Start all promises immediately
  const userPromise = fetchUser();
  const postsPromise = fetchPosts();
  const commentsPromise = fetchComments();
  
  // Wait for all to complete
  const user = await userPromise;
  const posts = await postsPromise;
  const comments = await commentsPromise;
  // Total: 1 second (longest promise)
  
  return { user, posts, comments };
}

// ‚úÖ BEST: Using Promise.all with async/await
async function loadDataBest() {
  const [user, posts, comments] = await Promise.all([
    fetchUser(),
    fetchPosts(),
    fetchComments()
  ]);
  
  return { user, posts, comments };
}
```

### Real-World Example: User Registration Flow
```javascript
const User = require('./models/User');
const sendEmail = require('./utils/email');
const generateToken = require('./utils/token');

async function registerUser(userData) {
  try {
    // 1. Check if user exists
    const existingUser = await User.findByEmail(userData.email);
    if (existingUser) {
      throw new Error("Email already registered");
    }
    
    // 2. Hash password
    const hashedPassword = await bcrypt.hash(userData.password, 10);
    
    // 3. Create user
    const user = await User.create({
      ...userData,
      password: hashedPassword
    });
    
    // 4. Generate verification token
    const token = await generateToken(user._id);
    
    // 5. Send welcome email (don't wait for it)
    sendEmail(user.email, token).catch(err => {
      console.error("Email failed:", err);
    });
    
    // 6. Return user data
    const { password, ...userWithoutPassword } = user;
    return {
      success: true,
      user: userWithoutPassword,
      token
    };
    
  } catch (error) {
    console.error("Registration failed:", error);
    return {
      success: false,
      error: error.message
    };
  }
}

// Usage
async function handleRegistration(req, res) {
  const result = await registerUser(req.body);
  
  if (result.success) {
    res.status(201).json(result);
  } else {
    res.status(400).json(result);
  }
}
```

### Top-Level Await (Modern JavaScript)
```javascript
// In modules (Node.js 14.8+, modern browsers)
const data = await fetch('/api/data');
console.log(data);

// No need to wrap in async function
```

---

## 7. Event Loop {#event-loop}

### What is the Event Loop?
The **Event Loop** is the mechanism that allows JavaScript to perform non-blocking I/O operations despite being single-threaded.

### JavaScript Runtime Components

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ         JavaScript Runtime              ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  1. Call Stack (Execution Context)      ‚îÇ
‚îÇ  2. Heap (Memory Allocation)            ‚îÇ
‚îÇ  3. Web APIs / Node APIs                ‚îÇ
‚îÇ  4. Callback Queue (Task Queue)         ‚îÇ
‚îÇ  5. Microtask Queue (Promise Queue)     ‚îÇ
‚îÇ  6. Event Loop                          ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### 1. Call Stack
- Execution context stack
- LIFO (Last In, First Out)
- Tracks function execution

```javascript
function first() {
  console.log("First");
  second();
}

function second() {
  console.log("Second");
  third();
}

function third() {
  console.log("Third");
}

first();

// Call Stack visualization:
// third()  ‚Üê Top
// second()
// first()
// (global) ‚Üê Bottom
```

### 2. Web APIs / Node APIs
Browser/Node provides APIs for async operations:
- `setTimeout`, `setInterval`
- DOM events
- `fetch`, `XMLHttpRequest`
- File system (Node.js)
- Timers, etc.

### 3. Callback Queue (Macrotask Queue)
Holds callbacks from:
- `setTimeout`
- `setInterval`
- I/O operations
- UI rendering

### 4. Microtask Queue (Job Queue)
Higher priority than Callback Queue. Holds:
- Promise `.then()` / `.catch()` / `.finally()`
- `async/await`
- `process.nextTick()` (Node.js)
- `MutationObserver`

### Event Loop Flow

```
1. Execute all synchronous code (Call Stack)
2. Check if Call Stack is empty
3. Execute ALL Microtasks (Promise callbacks)
4. Execute ONE Macrotask (setTimeout callback)
5. Repeat from step 2
```

### Visual Flow Diagram

```
     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
     ‚îÇ Call Stack  ‚îÇ
     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
            ‚îÇ
            ‚Üì
      Is it empty?
            ‚îÇ
      ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
      ‚îÇ YES       ‚îÇ NO ‚Üí Continue executing
      ‚Üì           ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îÇ
‚îÇ Microtasks  ‚îÇ   ‚îÇ
‚îÇ   (Empty?)  ‚îÇ   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îÇ
       ‚îÇ          ‚îÇ
       ‚Üì          ‚îÇ
    Execute       ‚îÇ
    ALL           ‚îÇ
    Microtasks    ‚îÇ
       ‚îÇ          ‚îÇ
       ‚Üì          ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îÇ
‚îÇ Macrotasks  ‚îÇ   ‚îÇ
‚îÇ (Callback   ‚îÇ   ‚îÇ
‚îÇ  Queue)     ‚îÇ   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îÇ
       ‚îÇ          ‚îÇ
       ‚Üì          ‚îÇ
    Execute       ‚îÇ
    ONE           ‚îÇ
    Macrotask     ‚îÇ
       ‚îÇ          ‚îÇ
       ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Example: Event Loop in Action

```javascript
console.log("1: Start");

setTimeout(() => {
  console.log("2: setTimeout");
}, 0);

Promise.resolve()
  .then(() => {
    console.log("3: Promise 1");
  })
  .then(() => {
    console.log("4: Promise 2");
  });

console.log("5: End");

// Output:
// 1: Start
// 5: End
// 3: Promise 1
// 4: Promise 2
// 2: setTimeout
```

**Explanation:**
1. `console.log("1: Start")` ‚Üí Call Stack ‚Üí Execute immediately
2. `setTimeout` ‚Üí Web API ‚Üí Callback Queue (after 0ms)
3. `Promise.resolve().then()` ‚Üí Microtask Queue
4. `console.log("5: End")` ‚Üí Call Stack ‚Üí Execute immediately
5. Call Stack empty ‚Üí Execute ALL Microtasks (Promises)
6. Execute ONE Macrotask (setTimeout)

### Complex Example

```javascript
console.log("Script start");

setTimeout(() => {
  console.log("setTimeout 1");
}, 0);

Promise.resolve()
  .then(() => {
    console.log("Promise 1");
    setTimeout(() => {
      console.log("setTimeout 2");
    }, 0);
  })
  .then(() => {
    console.log("Promise 2");
  });

setTimeout(() => {
  console.log("setTimeout 3");
  Promise.resolve().then(() => {
    console.log("Promise 3");
  });
}, 0);

console.log("Script end");

// Output:
// Script start
// Script end
// Promise 1
// Promise 2
// setTimeout 1
// setTimeout 3
// Promise 3
// setTimeout 2
```

**Step-by-Step:**
1. Synchronous: "Script start", "Script end"
2. Microtasks: "Promise 1", "Promise 2"
3. Macrotask: "setTimeout 1"
4. Macrotask: "setTimeout 3"
5. Microtask (from step 4): "Promise 3"
6. Macrotask (from step 2): "setTimeout 2"

### Why This Matters

**Blocking the Event Loop:**
```javascript
// ‚ùå BAD: Blocks event loop
function blockingOperation() {
  const start = Date.now();
  while (Date.now() - start < 5000) {
    // Blocks for 5 seconds
  }
  console.log("Done");
}

// UI freezes, no other code can run
```

**Non-Blocking Alternative:**
```javascript
// ‚úÖ GOOD: Non-blocking
function nonBlockingOperation() {
  setTimeout(() => {
    console.log("Done");
  }, 5000);
}

// Other code can run while waiting
```

### Priority Order

```
Highest Priority
    ‚Üì
1. Synchronous Code (Call Stack)
2. process.nextTick() [Node.js only]
3. Microtasks (Promises)
4. Macrotasks (setTimeout, setInterval)
    ‚Üì
Lowest Priority
```

---

## 8. Comparison & Best Practices {#comparison}

### When to Use What?

| Scenario | Use |
|----------|-----|
| Simple async operation | Callback |
| Multiple async operations in sequence | Promise chaining or async/await |
| Error handling needed | Promises or async/await with try/catch |
| Multiple independent operations | `Promise.all` with async/await |
| Operations where some may fail | `Promise.allSettled` |
| Clean, readable code | async/await |
| Library/API design | Return Promises |

### Evolution of Async Code

**Level 1: Callbacks (Old)**
```javascript
getData(function(a) {
  getMoreData(a, function(b) {
    getEvenMoreData(b, function(c) {
      console.log(c);
    });
  });
});
```

**Level 2: Promises (Better)**
```javascript
getData()
  .then(a => getMoreData(a))
  .then(b => getEvenMoreData(b))
  .then(c => console.log(c))
  .catch(err => console.error(err));
```

**Level 3: Async/Await (Best)**
```javascript
async function fetchData() {
  try {
    const a = await getData();
    const b = await getMoreData(a);
    const c = await getEvenMoreData(b);
    console.log(c);
  } catch (err) {
    console.error(err);
  }
}
```

### Best Practices

#### 1. Always Handle Errors
```javascript
// ‚úÖ GOOD
async function fetchData() {
  try {
    const data = await fetch(url);
    return data;
  } catch (error) {
    console.error("Error:", error);
    throw error;
  }
}

// ‚ùå BAD: Unhandled promise rejection
async function fetchData() {
  const data = await fetch(url);  // May throw error
  return data;
}
```

#### 2. Don't Mix Patterns
```javascript
// ‚ùå BAD: Mixing async/await with .then()
async function mixed() {
  const data = await fetchData();
  return data.then(result => result.value);  // Confusing!
}

// ‚úÖ GOOD: Consistent async/await
async function clean() {
  const data = await fetchData();
  return data.value;
}
```

#### 3. Use Promise.all for Parallel Operations
```javascript
// ‚ùå SLOW: Sequential (6 seconds total)
async function sequential() {
  const user = await fetchUser();        // 2s
  const posts = await fetchPosts();      // 2s
  const comments = await fetchComments(); // 2s
  return { user, posts, comments };
}

// ‚úÖ FAST: Parallel (2 seconds total)
async function parallel() {
  const [user, posts, comments] = await Promise.all([
    fetchUser(),      // All start together
    fetchPosts(),
    fetchComments()
  ]);
  return { user, posts, comments };
}
```

#### 4. Use Promise.allSettled for Independent Operations
```javascript
// ‚úÖ GOOD: Dashboard with multiple widgets
async function loadDashboard() {
  const results = await Promise.allSettled([
    fetchSales(),
    fetchInventory(),
    fetchAnalytics(),
    fetchNotifications()
  ]);
  
  // Show widgets that loaded successfully, errors for failed ones
  return results;
}
```

#### 5. Return Promises from Functions
```javascript
// ‚úÖ GOOD: Consistent API
function fetchUserData(id) {
  return User.findById(id);  // Returns a Promise
}

// Can be used with .then() or await
fetchUserData(1).then(user => console.log(user));
// or
const user = await fetchUserData(1);
```

#### 6. Avoid Callback Hell
```javascript
// ‚ùå BAD: Nested callbacks
getData(function(a) {
  getMoreData(a, function(b) {
    doSomething(b, function(c) {
      done(c);
    });
  });
});

// ‚úÖ GOOD: Flat async/await
async function process() {
  const a = await getData();
  const b = await getMoreData(a);
  const c = await doSomething(b);
  return done(c);
}
```

---

## Quick Reference

### Promise Methods
```javascript
Promise.resolve(value)        // Create fulfilled promise
Promise.reject(error)         // Create rejected promise
Promise.all([...])            // All must succeed (fast-fail)
Promise.allSettled([...])     // Wait for all (never rejects)
Promise.race([...])           // First to settle wins
Promise.any([...])            // First to fulfill wins
```

### Async/Await Syntax
```javascript
// Function declaration
async function name() { }

// Arrow function
const name = async () => { };

// Method
class MyClass {
  async myMethod() { }
}

// IIFE (Immediately Invoked Function Expression)
(async () => {
  await doSomething();
})();
```

### Error Handling Patterns
```javascript
// Pattern 1: try/catch
try {
  await asyncOperation();
} catch (error) {
  console.error(error);
}

// Pattern 2: .catch()
asyncOperation().catch(error => console.error(error));

// Pattern 3: Conditional
const result = await asyncOperation().catch(err => null);
if (!result) {
  // Handle error
}
```

---

## Practice Questions

1. What is the output of this code?
```javascript
console.log(1);
setTimeout(() => console.log(2), 0);
Promise.resolve().then(() => console.log(3));
console.log(4);
```

2. How would you run 5 API calls in parallel and wait for all of them?

3. What's the difference between `Promise.all` and `Promise.allSettled`?

4. Convert this callback to async/await:
```javascript
fs.readFile('file.txt', (err, data) => {
  if (err) throw err;
  console.log(data);
});
```

5. Why does this code run sequentially instead of in parallel?
```javascript
async function loadData() {
  const data1 = await fetch('/api/1');
  const data2 = await fetch('/api/2');
  return [data1, data2];
}
```

---

## Summary

- **Callbacks**: Functions passed as arguments, can lead to callback hell
- **Promises**: Objects representing future values, allow chaining
- **Promise.all**: Execute multiple promises in parallel, fail-fast
- **Promise.allSettled**: Wait for all promises regardless of outcome
- **Async/Await**: Syntactic sugar for promises, most readable
- **Event Loop**: Manages async operations with Call Stack, Microtasks, and Macrotasks

**Golden Rule:** Use async/await for clean, readable asynchronous code! üöÄ

---

**End of Notes**
