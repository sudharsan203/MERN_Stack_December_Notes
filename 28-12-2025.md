# Class Notes - December 28, 2025
## Topic: Node.js E-Commerce API - Database Setup & Authentication

---

## Overview
Today we discussed the foundational architecture of a MongoDB-based e-commerce API built with Node.js and Express. We covered database connectivity, user models, authentication routes, and server initialization.

---

## 1. Database Configuration (`config/database.js`)

### Purpose
Establishes and manages the MongoDB connection for the entire application.

### Key Components

#### **Connection Setup**
```javascript
const uri = "mongodb://localhost:27017";
const client = new MongoClient(uri);
const dbName = "MobileECommerce";
```
- Uses MongoDB native driver
- Connects to local MongoDB instance on default port 27017
- Database name: `MobileECommerce`

#### **Connection Function**
```javascript
async function connectDB() {
  await client.connect();
  db = client.db(dbName);
  return db;
}
```
- **Asynchronous**: Uses `async/await` for non-blocking operations
- Establishes connection when called
- Stores database instance in module-level variable `db`
- Throws error if connection fails

#### **Database Accessor**
```javascript
function getDB() {
  if (!db) {
    throw new Error("Database not initialized. Call connectDB first.");
  }
  return db;
}
```
- **Safety check**: Ensures database is connected before allowing access
- Prevents errors from accessing uninitialized database
- Used throughout the application to get database instance

#### **Exports**
```javascript
module.exports = { connectDB, getDB, ObjectId };
```
- `connectDB`: Initialize connection (called once at startup)
- `getDB`: Get database instance (called by models)
- `ObjectId`: MongoDB's ObjectId class for working with `_id` fields

---

## 2. User Model (`models/User.js`)

### Purpose
Implements the User data model with CRUD (Create, Read, Update, Delete) operations.

### Design Pattern
**Active Record Pattern** - The model class contains both data structure and database operations.

### Key Methods

#### **getCollection()**
```javascript
static getCollection() {
  return getDB().collection('users');
}
```
- Static method (called on class, not instance)
- Returns reference to 'users' collection
- Used internally by all other methods

#### **create(userData)**
```javascript
static async create(userData) {
  const user = {
    name: userData.name,
    email: userData.email,
    password: userData.password,
    role: userData.role || 'customer',
    phone: userData.phone,
    address: userData.address,
    createdAt: new Date(),
    updatedAt: new Date()
  };
  const result = await this.getCollection().insertOne(user);
  return { ...user, _id: result.insertedId };
}
```
- **Default values**: Sets role to 'customer' if not provided
- **Timestamps**: Automatically adds createdAt and updatedAt
- **Returns**: Complete user object including MongoDB-generated `_id`
- **Note**: Password is stored in plain text (DEMO ONLY - should be hashed in production)

#### **findByEmail(email)**
```javascript
static async findByEmail(email) {
  return await this.getCollection().findOne({ email });
}
```
- Used for login and duplicate email checking
- Returns `null` if no user found
- Returns complete user document if found

#### **findById(id)**
```javascript
static async findById(id) {
  return await this.getCollection().findOne({ _id: new ObjectId(id) });
}
```
- Converts string ID to MongoDB ObjectId
- Used for retrieving user profiles
- Critical: Must use `new ObjectId(id)` to match MongoDB's `_id` format

#### **updateById(id, updateData)**
```javascript
static async updateById(id, updateData) {
  updateData.updatedAt = new Date();
  const result = await this.getCollection().updateOne(
    { _id: new ObjectId(id) },
    { $set: updateData }
  );
  return result;
}
```
- Automatically updates the `updatedAt` timestamp
- Uses MongoDB's `$set` operator to update specific fields
- Returns result object with `matchedCount`, `modifiedCount`, etc.

#### **findAll(filter = {})**
```javascript
static async findAll(filter = {}) {
  return await this.getCollection().find(filter).toArray();
}
```
- Retrieves all users (or filtered subset)
- Returns array of user documents
- Used by admin endpoints

#### **deleteById(id)**
```javascript
static async deleteById(id) {
  return await this.getCollection().deleteOne({ _id: new ObjectId(id) });
}
```
- Permanently removes user from database
- Returns result with `deletedCount`

---

## 3. Server Setup (`index.js`)

### Purpose
Main entry point - configures Express server, middleware, routes, and starts the application.

### Middleware Configuration
```javascript
app.use(cors());
app.use(express.json());
```
- **CORS**: Allows cross-origin requests (frontend can be on different domain)
- **express.json()**: Parses incoming JSON payloads in request body

### Route Organization
```javascript
// Customer routes
app.use('/api/mobiles', mobilesRoutes);
app.use('/api/cart', cartRoutes);
app.use('/api/orders', ordersRoutes);

// Admin routes
app.use('/api/admin/mobiles', adminMobilesRoutes);
app.use('/api/admin/orders', adminOrdersRoutes);
app.use('/api/admin/users', adminUsersRoutes);

// Auth routes
app.use('/api/auth', authRoutes);
```
- **Modular routing**: Each feature has its own route file
- **Clear separation**: Customer vs Admin endpoints
- **RESTful**: Uses standard HTTP methods (GET, POST, PUT, DELETE)

### Server Initialization
```javascript
async function startServer() {
  try {
    await connectDB();  // Connect to database first
    app.listen(PORT, () => {
      console.log(`Server is running on http://localhost:${PORT}`);
    });
  } catch (error) {
    console.error("Failed to start server:", error);
    process.exit(1);  // Exit if DB connection fails
  }
}
```
- **Async initialization**: Ensures database is ready before accepting requests
- **Error handling**: Exits gracefully if database connection fails
- **Sequential startup**: DB → Server

---

## 4. Authentication Routes (`routes/auth.js`)

### Purpose
Handles user registration, login, and profile retrieval.

### Endpoints

#### **POST /api/auth/register**
```javascript
AuthRoutes.post('/register', express.json(), async (req, res) => {
  // 1. Check if user exists
  const existingUser = await User.findByEmail(email);
  if (existingUser) {
    return res.status(400).json({ 
      success: false, 
      error: 'Email already registered' 
    });
  }
  
  // 2. Create user
  const user = await User.create({...});
  
  // 3. Remove password from response
  const { password: pwd, ...userWithoutPassword } = user;
  
  // 4. Send response
  res.status(201).json({ 
    success: true, 
    data: userWithoutPassword 
  });
});
```
**Flow:**
1. Extract user data from request body
2. Check for duplicate email
3. Create user in database
4. Remove password from response (security)
5. Return user data with 201 (Created) status

**Security Note**: Destructuring `const { password: pwd, ...userWithoutPassword }` removes password from response object.

#### **POST /api/auth/login**
```javascript
AuthRoutes.post('/login', express.json(), async (req, res) => {
  // 1. Find user by email
  const user = await User.findByEmail(email);
  if (!user) {
    return res.status(401).json({ error: 'Invalid credentials' });
  }
  
  // 2. Check password
  if (user.password !== password) {
    return res.status(401).json({ error: 'Invalid credentials' });
  }
  
  // 3. Remove password and send user data
  const { password: pwd, ...userWithoutPassword } = user;
  res.json({ success: true, data: userWithoutPassword });
});
```
**Flow:**
1. Find user by email
2. Compare passwords (plain text - should use bcrypt in production)
3. Return user data if valid
4. Return 401 (Unauthorized) if invalid

**Status Codes:**
- `401`: Authentication failed (wrong email/password)
- `200`: Login successful

#### **GET /api/auth/profile/:id**
```javascript
AuthRoutes.get('/profile/:id', async (req, res) => {
  const user = await User.findById(req.params.id);
  if (!user) {
    return res.status(404).json({ error: 'User not found' });
  }
  const { password, ...userWithoutPassword } = user;
  res.json({ success: true, data: userWithoutPassword });
});
```
**Flow:**
1. Extract user ID from URL parameter
2. Retrieve user from database
3. Return user data without password

**URL Parameter**: `:id` is a route parameter accessed via `req.params.id`

---

## Key Concepts Covered

### 1. **Async/Await Pattern**
- All database operations are asynchronous
- Use `async` function declaration
- Use `await` keyword for promises
- Better than callbacks - cleaner, more readable

### 2. **Error Handling**
```javascript
try {
  // Database operations
} catch (error) {
  res.status(500).json({ success: false, error: error.message });
}
```
- Wrap async operations in try-catch
- Return appropriate HTTP status codes
- Send error messages to client

### 3. **HTTP Status Codes Used**
- `200`: Success (OK)
- `201`: Resource created successfully
- `400`: Bad request (validation error)
- `401`: Unauthorized (authentication failed)
- `404`: Resource not found
- `500`: Internal server error

### 4. **Response Format**
```javascript
{
  success: true/false,
  message: "...",
  data: {...},
  error: "..."
}
```
- Consistent structure across all endpoints
- `success` flag for quick status check
- `data` contains the actual payload
- `error` for error messages

### 5. **Security Considerations Discussed**
- ❌ **Current**: Passwords stored in plain text
- ✅ **Production**: Should use bcrypt for password hashing
- ✅ **Good**: Passwords removed from API responses
- ❌ **Current**: No JWT tokens for session management
- ✅ **Production**: Should implement JWT-based authentication

---

## Database Schema - Users Collection

```javascript
{
  _id: ObjectId("..."),           // Auto-generated by MongoDB
  name: "John Doe",                // User's full name
  email: "john@example.com",       // Unique identifier for login
  password: "password123",         // Plain text (DEMO ONLY)
  role: "customer",                // "customer" or "admin"
  phone: "1234567890",             // Contact number
  address: "123 Main St",          // Delivery address
  createdAt: ISODate("..."),       // Registration timestamp
  updatedAt: ISODate("...")        // Last modification timestamp
}
```

---

## Flow Diagram: User Registration

```
Client Request (POST /api/auth/register)
    ↓
Express Router receives request
    ↓
Extract data from req.body
    ↓
User.findByEmail(email) → Check if email exists
    ↓
    ├─ If exists → Return 400 error
    └─ If not exists → Continue
        ↓
    User.create(userData) → Insert into MongoDB
        ↓
    Remove password from response
        ↓
    Return 201 with user data
```

---

## Important Notes

1. **Module Pattern**: Each file exports specific functions/classes
   - Promotes code reusability
   - Separation of concerns
   - Easier testing and maintenance

2. **Static Methods**: Used in User model
   - Called on class: `User.create()`
   - Don't require instance creation
   - Perfect for database operations

3. **Middleware**: Functions that process requests
   - `express.json()` parses JSON bodies
   - `cors()` enables cross-origin requests
   - Custom middleware can be added for authentication

4. **Environment**: Currently hardcoded values
   - Production should use environment variables
   - Example: `process.env.MONGODB_URI`
   - Use `.env` file with `dotenv` package

---

## Next Steps / To-Do

- [ ] Implement password hashing (bcrypt)
- [ ] Add JWT token-based authentication
- [ ] Add input validation (express-validator)
- [ ] Implement rate limiting for API endpoints
- [ ] Add environment variables for configuration
- [ ] Create middleware for authentication/authorization
- [ ] Add logging (Winston or Morgan)
- [ ] Implement proper error handling middleware

---

## Questions to Review

1. Why do we use `static` methods in the User model?
2. What's the difference between `findOne()` and `find()` in MongoDB?
3. Why is it important to remove passwords from API responses?
4. What would happen if we don't call `connectDB()` before starting the server?
5. How does the `getDB()` function prevent errors from uninitialized database?

---

**End of Notes**
